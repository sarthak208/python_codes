from group import math
import math
import hashlib

#I will become cds AIR 1 in future
''' who will become 2nd pm of india and when will become India hindu country'''
  class lover:
      my_solution="&5262";
      class lover&5262;
      def __init__(self,my_solution):
          self.my_solution=solution
          
      obj=solution(my_solution&5262)
      print(obj)  
      
      print(lover.my_solution)
      
      lover.my_solution=&5262;
      for my_solution&5262;
      print(lover.my_solution)
      
        class action(lover):
         def showdetails(a,b):
             a=1.93
             b=5\7
             c=input("enter the value of c")
             print(c)
             print(float(a))
             print(float(b))
             print("the value of a\nb")
      try:
          print("matched a case")
          
    exception details as a and b:
          print(" first and second case")    
                 
       finally:
           print("no other case")   
                         
          while a==1.93:
              print(a)     
       
       for x in a:
           if x!=a:
               break
               
           elif:
               break
               
         else:
             break
      print("x is not with a")   
      print("x is with a")   
      print("x may be with a") 
      
      for k in range(5):
          print(k)
          
      else:
          print("use othe range")
          
     if __"name"__=="main": print("use that method")
     else:print("use method as it is")
      
      o={"solider","army","bjp","motherland"}
        print(o)
         print(o[1:3])   
         x=len[o]
         print(o)  
         str1="indian army is legend"
         print(str1.isalnum())
         w="thunder bome"
            print(w.islower())      
            print(w.isprintable())    
       
       def o():
           match_o():
           
           case_1="solider" 
              print("solider")    
              
           case_2="army"
              print("army")
              
              case_3="bjp"
              print("bjp")
              
              case_4="motherland"
              print("motherland")
              
              case_="unknown"
              print("no other case")
              
          r=53
          i=100
          def cube(r,i,g):
              print(cube(r))    
              print(cube(i))
        
        gf=["srushti","vaishnavi","sharwani","shivangi"]  
        print(gf[0:-3])   
        print(gf[2])
        gf.append()
        gf.reverse(5)
        print(gf.count())
        print(gf.index(1))
       
       t=gf.copy(3) 
       print(gf)
        
        tup=(5,81,1000,536)
        print(tup)
        print(tup[0:1])
        print(type(tup))
        print(type(tup[1:0]))
       val=tup.count(1)
       print(val)
       val2=tup.index(1,3)
       print(val2)
       
       g='''I will prove all my dream in reality'''
       print(f"cube().__doc__ the value of g{2}")
       
       cube():
       
     set={"japan","china","usa","india"}  
       print(set.union(2))
       print(set.intersection(1))
       dict={"mumbai","chennai","Bengaluru", "kolkata"}
       print(dict.intersection_update(set))
       
       cant={s1:"pizza",s2:"burger",s3:"maggi",s4:"pasta"}
       print(s1.pop("pasta"))
       print(s2.update())
       print(s4.clear())
       
       words=63\5
       letter=519
       if(words<letter):
           print("words is small than letter")
           
           raise value error("values between 63 and 519")
           
       roots=[51,919,63,183,192]
         for roots in roots enumerate(roots):
             print(roots)
             
      import os
      def os():
          break
          list1=[526,919,93]
          if(os.path.exists("data"))
              os.mkdir("data"):
              
          for os.path.exists(3):
              os.list1dir(os.path.exists)  
              print(os.path.exists(3))
              
              def method(s=636):
                  lambda:s
                  print(s)
                  
                  f=63
                  
                  def solve():
                      tool=6260
                      print(tool)
                      
                      print(f)
                      
          file=open("myfile.txt", 'r')  
          print(file)
          file2=open("myfile.txt", 'rw')
          print(file2)
          
          f.close():
          print(file is file2)
          print(file==file2)
          
          words={5,99,8192,737,81}
          words=f.readline()
          print(words)
          
          with open("myfile.txt", 'rw') as f:
              f.read("my lover")
              print(f.read())
              
              f.seek(3)
              
              def cars():
                  cars="skoda,Volkswagen, oddi,ciaz"
                  l=cars(map([2]))
                  print(l)
                  custody=lover(617):
                  print(custody)
                  
                  @greet
                  def accept(mx):
                      return mx
                      
                      def fc():
                          print(fc={mx})
               
               class city:
                   def __init__(self,name,weather):
                       self.name=name
                       self.weather=weather
                       
                       def show():
                           print(f"the value{name})          
                          
                         @city show
                         def show(self,todo="hzh"):
                             self._todo="hzh"
                             
                       life=city("delhi","cold"):
                       print(self._city)      
                    # program to illustrate public access modifier in a class


class Geek:

    # constructor
    def __init__(self, name, age):
        # public data members
        self.geekName = name
        self.geekAge = age
    # public member function
    def displayAge(self):
        print("Age: ", self.geekAge)
# creating object of the class
obj = Geek("R2J", 20)
print("List of fields and methods inside obj:", dir(obj))
print("Name:", obj.geekName)
obj.displayAge()   
                       # program to illustrate protected access modifier in a class

# super class
class Student:

    # protected data members
    _name = None
    _roll = None
    _branch = None

    # constructor
    def __init__(self, name, roll, branch):
        self._name = name
        self._roll = roll
        self._branch = branch

    # protected member function
    def _displayRollAndBranch(self):

        # accessing protected data members
        print("Roll:", self._roll)
        print("Branch:", self._branch)

# derived class
class Geek(Student):

    # constructor
    def __init__(self, name, roll, branch):
        Student.__init__(self, name, roll, branch)

    # public member function
    def displayDetails(self):

              # accessing protected data members of super class
        print("Name:", self._name)

        # accessing protected member functions of super class
        self._displayRollAndBranch()


stu = Student("Alpha", 1234567, "Computer Science")
print(dir(stu))

# protected members and methods can be still accessed
print(stu._name)
stu._displayRollAndBranch()

# Throws error
# print(stu.name)
# stu.displayRollAndBranch()

# creating objects of the derived class
obj = Geek("R2J", 1706256, "Information Technology")
print("")
print(dir(obj))

# calling public member functions of the class
obj.displayDetails()# program to illustrate private access modifier in a class

class Geek:

    # private members
    __name = None
    __roll = None
    __branch = None

    # constructor
    def __init__(self, name, roll, branch):
        self.__name = name
        self.__roll = roll
        self.__branch = branch

    # private member function
    def __displayDetails(self):

        # accessing private data members
        print("Name:", self.__name)
        print("Roll:", self.__roll)
        print("Branch:", self.__branch)

    # public member function
    def accessPrivateFunction(self):

        # accessing private member function
        self.__displayDetails()

# creating object
obj = Geek("R2J", 1706256, "Information Technology")

print(dir(obj))
print("")

# Throws error
# obj.__name
# obj.__roll
# obj.__branch
# obj.__displayDetails()

# To access private members of a class
print(obj._Geek__name)
print(obj._Geek__roll)
print(obj._Geek__branch)
obj._Geek__displayDetails()

print("")

# calling public member function of the class
obj.accessPrivateFunction()
class Maths(): 
      
    @staticmethod
    def addNum(num1, num2): 
        return num1 + num2 
          
# Driver's code 
if __name__ == "__main__": 
      
    # Calling method of class 
    # without creating instance 
    res = Maths.addNum(1, 2) 
    print("The result is", res)       
                         
      class Car:
    def __init__(self, brand, model):
        # Instance attributes
        self.brand = brand
        self.model = model

# Creating instances of the Car class
car1 = Car(&quot;Toyota&quot;, &quot;Camry&quot;)
car2 = Car(&quot;Honda&quot;, &quot;Civic&quot;)

# Accessing instance attributes
print(f&quot;{car1.brand} {car1.model}&quot;)  
print(f&quot;{car2.brand} {car2.model}&quot;)
